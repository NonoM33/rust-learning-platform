---
import BaseLayout from '../layouts/BaseLayout.astro';
import { RustPlayground } from '../components/editor/RustPlayground';
---

<BaseLayout title="Playground Rust">
  <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">
        Playground Rust
      </h1>
      <p class="text-gray-600 dark:text-gray-400">
        Ecris et execute du code Rust directement dans ton navigateur. Utilise l'API officielle de play.rust-lang.org.
      </p>
    </div>

    <RustPlayground
      client:only="react"
      initialCode={`// Bienvenue dans le Playground Rust ! ðŸ¦€
//
// Quelques exemples pour commencer :

fn main() {
    // Variables et mutabilite
    let x = 5;          // immutable
    let mut y = 10;     // mutable
    y += x;
    println!("x = {}, y = {}", x, y);

    // Pattern matching
    let number = 13;
    match number {
        1 => println!("Un!"),
        2..=12 => println!("Entre 2 et 12"),
        13 => println!("Treize - lucky number!"),
        _ => println!("Autre chose"),
    }

    // Iterateurs
    let numbers: Vec<i32> = (1..=5).collect();
    let doubled: Vec<i32> = numbers.iter().map(|n| n * 2).collect();
    println!("Doubled: {:?}", doubled);
}`}
    />

    <!-- Examples -->
    <div class="mt-12">
      <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-6">
        Exemples rapides
      </h2>
      <div class="grid md:grid-cols-2 gap-4">
        <button
          data-code={`fn main() {
    // Ownership basique
    let s1 = String::from("hello");
    let s2 = s1;  // s1 est "moved" vers s2

    // println!("{}", s1);  // Erreur! s1 n'est plus valide
    println!("{}", s2);     // OK!

    // Pour copier, utilise clone()
    let s3 = s2.clone();
    println!("s2 = {}, s3 = {}", s2, s3);
}`}
          class="example-btn text-left p-4 bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-rust-300 dark:hover:border-rust-700 transition-colors"
        >
          <h3 class="font-medium text-gray-900 dark:text-white mb-1">Ownership</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400">Comprendre le move et clone</p>
        </button>

        <button
          data-code={`fn main() {
    let s = String::from("hello");

    // Borrowing immutable
    let len = calculate_length(&s);
    println!("Length of '{}' is {}", s, len);

    // Borrowing mutable
    let mut s2 = String::from("hello");
    change(&mut s2);
    println!("Changed: {}", s2);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn change(s: &mut String) {
    s.push_str(", world!");
}`}
          class="example-btn text-left p-4 bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-rust-300 dark:hover:border-rust-700 transition-colors"
        >
          <h3 class="font-medium text-gray-900 dark:text-white mb-1">Borrowing</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400">References et mutabilite</p>
        </button>

        <button
          data-code={`#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    Color(u8, u8, u8),
}

fn main() {
    let messages = vec![
        Message::Quit,
        Message::Move { x: 10, y: 20 },
        Message::Write(String::from("Hello")),
        Message::Color(255, 128, 0),
    ];

    for msg in messages {
        match msg {
            Message::Quit => println!("Quit!"),
            Message::Move { x, y } => println!("Move to ({}, {})", x, y),
            Message::Write(text) => println!("Write: {}", text),
            Message::Color(r, g, b) => println!("Color: rgb({}, {}, {})", r, g, b),
        }
    }
}`}
          class="example-btn text-left p-4 bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-rust-300 dark:hover:border-rust-700 transition-colors"
        >
          <h3 class="font-medium text-gray-900 dark:text-white mb-1">Enums & Pattern Matching</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400">Enums avec donnees et match</p>
        </button>

        <button
          data-code={`use std::collections::HashMap;

fn main() {
    // Vec
    let mut numbers = vec![1, 2, 3, 4, 5];
    numbers.push(6);

    // Iterateurs et transformations
    let squared: Vec<i32> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|x| x * x)
        .collect();
    println!("Even squares: {:?}", squared);

    // HashMap
    let mut scores = HashMap::new();
    scores.insert("Alice", 100);
    scores.insert("Bob", 85);

    for (name, score) in &scores {
        println!("{}: {}", name, score);
    }
}`}
          class="example-btn text-left p-4 bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-rust-300 dark:hover:border-rust-700 transition-colors"
        >
          <h3 class="font-medium text-gray-900 dark:text-white mb-1">Collections & Iterateurs</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400">Vec, HashMap et chaines</p>
        </button>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  document.querySelectorAll('.example-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const code = btn.getAttribute('data-code');
      // Find the Monaco editor and update its content
      const event = new CustomEvent('loadExample', { detail: { code } });
      window.dispatchEvent(event);
      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  });
</script>
